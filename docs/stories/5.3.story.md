# Story 5.3: 智能故障转移

> **Epic 5**: 负载均衡与故障转移 (FR11-FR14)
> **Story**: 5.3 - 智能故障转移
> **优先级**: P0 (MUST HAVE)
> **估算**: 1.5 天

---

## 1. 需求概述

根据 PRD 需求 FR13-FR14,实现智能故障转移机制:

### FR13: 自动故障转移

**流程**:
1. 按优先级排序所有映射
2. 尝试优先级最高的供应商
3. 如果失败且满足故障条件 → 尝试下一个
4. 最多重试 N 次 (默认 3 次,可配置)
5. 所有供应商都失败 → 返回最后一个错误

**示例**:
```
统一模型: claude-sonnet-4
├── 供应商 A (优先级: 1) → 超时 → 故障转移
├── 供应商 B (优先级: 2) → 成功 ✓
└── 供应商 C (优先级: 3) → (未使用)
```

### FR14: 故障恢复

**机制**:
- 通过健康检查恢复标记为"不可用"的供应商
- 或设置超时 (5 分钟后自动恢复)

**验收标准**:
- [ ] 故障转移成功率 > 95%
- [ ] 重试次数不超过 3 次
- [ ] 故障转移延迟 < 5s
- [ ] 集成测试: 主供应商故障场景
- [ ] 日志记录完整 (包含故障原因)

---

## 2. 技术设计

### 2.1 数据结构

```go
// FailoverExecutor 故障转移执行器
type FailoverExecutor struct {
    balancer         LoadBalancer
    failureDetector  FailureDetector
    config           *FailoverConfig
}

// FailoverConfig 故障转移配置
type FailoverConfig struct {
    MaxRetries       int           // 最大重试次数,默认 3
    EnableFailover   bool          // 是否启用故障转移,默认 true
}

// FailoverResult 故障转移结果
type FailoverResult struct {
    SelectedProvider *mapping.ResolvedMapping  // 成功的供应商映射
    AttemptCount     int                       // 尝试次数
    FailedProviders  []FailureAttempt          // 失败的供应商列表
}

// FailureAttempt 故障转移尝试记录
type FailureAttempt struct {
    ProviderID       uint          // 供应商 ID
    TargetModel      string        // 目标模型
    FailureType      FailureType   // 故障类型
    Error            error         // 错误信息
}
```

### 2.2 核心算法

#### 故障转移流程

```go
func (f *FailoverExecutor) SelectProviderWithFailover(
    mappings []*mapping.ResolvedMapping,
) (*FailoverResult, error) {

    if len(mappings) == 0 {
        return nil, errors.New("no available providers")
    }

    // 1. 按优先级排序 (Priority 从小到大)
    sortedMappings := f.sortByPriority(mappings)

    result := &FailoverResult{
        FailedProviders: []FailureAttempt{},
    }

    // 2. 按优先级顺序尝试每个供应商
    for i, mapping := range sortedMappings {
        // 检查是否超过重试次数
        if i >= f.config.MaxRetries {
            break
        }

        // 检查供应商是否可用 (未在冷却期)
        if !f.failureDetector.IsAvailable(mapping.ProviderID) {
            result.FailedProviders = append(result.FailedProviders, FailureAttempt{
                ProviderID:  mapping.ProviderID,
                TargetModel: mapping.TargetModel,
                FailureType: FailureTypeCooldown,
                Error:       errors.New("provider in cooldown period"),
            })
            result.AttemptCount++
            continue
        }

        // 3. 选择该供应商
        result.SelectedProvider = mapping
        result.AttemptCount++
        return result, nil
    }

    // 4. 所有供应商都不可用
    return result, errors.New("all providers unavailable or in cooldown")
}
```

#### 优先级排序

```go
func (f *FailoverExecutor) sortByPriority(
    mappings []*mapping.ResolvedMapping,
) []*mapping.ResolvedMapping {
    sorted := make([]*mapping.ResolvedMapping, len(mappings))
    copy(sorted, mappings)

    sort.Slice(sorted, func(i, j int) bool {
        return sorted[i].Priority < sorted[j].Priority
    })

    return sorted
}
```

---

## 3. 集成设计

### 3.1 与负载均衡器集成

```go
// 负载均衡 + 故障转移的完整流程
func SelectProviderIntelligent(
    mappings []*mapping.ResolvedMapping,
    balancer LoadBalancer,
    failover *FailoverExecutor,
) (*mapping.ResolvedMapping, error) {

    // 1. 先使用负载均衡器选择
    selected := balancer.SelectProvider(mappings)
    if selected != nil && failover.failureDetector.IsAvailable(selected.ProviderID) {
        return selected, nil
    }

    // 2. 如果负载均衡选择的供应商不可用,使用故障转移
    result, err := failover.SelectProviderWithFailover(mappings)
    if err != nil {
        return nil, err
    }

    return result.SelectedProvider, nil
}
```

### 3.2 与故障检测器集成

故障转移执行器依赖故障检测器的以下功能:
- `IsAvailable(providerID uint) bool`: 检查供应商是否可用
- `RecordFailure(providerID uint, failureType FailureType)`: 记录故障
- `RecordSuccess(providerID uint)`: 记录成功

---

## 4. 测试策略

### 4.1 单元测试

**测试用例**:

1. **基础故障转移 - 第一个供应商可用**
   - 3 个供应商,全部可用
   - 验证选择优先级最高的 (Priority = 1)

2. **故障转移 - 第一个供应商不可用**
   - 3 个供应商,第一个在冷却期
   - 验证选择第二个供应商 (Priority = 2)

3. **多次故障转移**
   - 3 个供应商,前两个不可用
   - 验证选择第三个供应商 (Priority = 3)

4. **重试次数限制**
   - 5 个供应商,配置 MaxRetries = 3
   - 全部不可用
   - 验证只尝试了前 3 个

5. **全部供应商不可用**
   - 3 个供应商,全部在冷却期
   - 验证返回错误

6. **优先级排序正确性**
   - 提供乱序的映射列表 (Priority: 3, 1, 2)
   - 验证按 1, 2, 3 顺序尝试

### 4.2 场景测试

**测试场景**:

1. **真实故障转移流程**
   - 模拟主供应商故障 (冷却期 100ms)
   - 调用故障转移
   - 验证选择备用供应商
   - 等待冷却期结束
   - 验证主供应商恢复

2. **与负载均衡器协同**
   - 负载均衡选中供应商 A
   - 供应商 A 在冷却期
   - 故障转移到供应商 B
   - 验证最终选择 B

3. **高并发场景**
   - 50 个 goroutine 同时请求故障转移
   - 验证并发安全
   - 验证故障计数正确

---

## 5. 性能要求

### 5.1 延迟要求

- **无故障转移场景** (第一个供应商直接可用):
  - 延迟 < 1ms

- **单次故障转移** (切换到第二个供应商):
  - 额外延迟 < 10ms

- **多次故障转移** (最多 3 次):
  - 总延迟 < 30ms

### 5.2 并发性能

- 支持 100+ 并发请求
- 无竞态条件
- 无死锁

---

## 6. 验收标准

### 6.1 功能验收

- [ ] **故障转移成功率 > 95%**
  - 至少有 1 个可用供应商时,成功选择
  - 测试 1000 次,成功率 > 95%

- [ ] **优先级排序正确**
  - 始终按 Priority 从小到大尝试

- [ ] **重试次数限制正确**
  - 不超过 MaxRetries 配置值

- [ ] **冷却期机制正常**
  - 处于冷却期的供应商被跳过
  - 冷却期结束后自动恢复

### 6.2 性能验收

- [ ] **延迟符合要求**
  - 无故障转移 < 1ms
  - 单次故障转移 < 10ms

- [ ] **并发安全**
  - 通过 race detector 检测
  - 100 并发无问题

### 6.3 代码质量

- [ ] **单元测试覆盖率 > 90%**
- [ ] **场景测试覆盖所有关键流程**
- [ ] **代码符合 Go 最佳实践**

---

## 7. 实现清单

### 7.1 代码实现

- [ ] 创建 `internal/balancer/failover.go`
- [ ] 实现 `FailoverExecutor` 结构体
- [ ] 实现 `SelectProviderWithFailover()` 方法
- [ ] 实现 `sortByPriority()` 辅助方法
- [ ] 实现 `SelectProviderIntelligent()` 集成函数

### 7.2 测试实现

- [ ] 创建 `internal/balancer/failover_test.go`
- [ ] 实现 6 个单元测试用例
- [ ] 创建 `internal/balancer/failover_scenario_test.go`
- [ ] 实现 3 个场景测试

### 7.3 文档更新

- [ ] 更新本 Story 文档标记完成状态

---

## 8. 依赖关系

### 8.1 依赖模块

- **Story 5.1 (加权随机负载均衡器)**:
  - 使用 `LoadBalancer` 接口
  - 与负载均衡器协同工作

- **Story 5.2 (故障检测逻辑)**:
  - 使用 `FailureDetector` 接口
  - 依赖 `IsAvailable()` 判断可用性
  - 依赖冷却期机制

- **Story 4.3 (路由解析逻辑)**:
  - 依赖 `ResolvedMapping` 数据结构
  - 依赖 Priority 字段

---

## 9. 参考资料

- [PRD - Epic 5: 负载均衡与故障转移](../prd.md#epic-5-负载均衡与故障转移-fr11-fr14)
- [Story 5.1 - 加权随机负载均衡器](./5.1.story.md)
- [Story 5.2 - 故障检测逻辑](./5.2.story.md)

---

**Story 状态**: Done
**创建时间**: 2025-10-02
