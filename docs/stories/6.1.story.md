# Story 6.1: Token 生成和存储

**Epic**: Epic 6 - 令牌管理 (FR15-FR16)
**优先级**: P0 (MUST HAVE)
**估算时间**: 1 天
**状态**: In Progress

---

## 用户故事

作为一个 **Siriusx-API 管理员**，我希望能够**生成唯一的 API Token 并安全存储**，以便用户可以使用这些 Token 来认证 Claude Code CLI 请求。

## 需求背景 (FR15)

- **Token 格式**: `sk-` + 32 字节 base64 编码随机字符串
- **用途**: 用户在 Claude Code CLI 中设置 `ANTHROPIC_API_KEY`
- **字段要求**:
  - 名称: "我的开发 Token"
  - Token: "sk-xxx"
  - 启用状态: true/false
  - 过期时间: 可选

## 验收标准

### AC1: Token 数据模型
- [ ] 定义 `Token` 结构体，包含以下字段：
  - ID (主键)
  - Name (名称，varchar(100)，非空)
  - Token (令牌值，varchar(100)，唯一索引，非空)
  - Enabled (启用状态，布尔值，默认 true)
  - ExpiresAt (过期时间，可为空)
  - CreatedAt (创建时间)
  - UpdatedAt (更新时间)
- [ ] GORM 自动迁移成功创建 `tokens` 表

### AC2: Token 生成逻辑
- [ ] Token 格式符合正则表达式: `^sk-[a-zA-Z0-9+/]{43}$`
- [ ] Token 唯一性保证 100% (无重复)
- [ ] 使用加密安全的随机数生成器 (crypto/rand)

### AC3: Token CRUD API
- [ ] `POST /api/tokens` - 创建 Token
  - 请求体: `{"name": "我的开发 Token", "expires_at": "2025-12-31T23:59:59Z"}`
  - 响应: 完整的 Token 对象（包含完整 Token 值）
  - HTTP 状态码: 201 Created
- [ ] `GET /api/tokens` - 查询 Token 列表
  - 响应: Token 列表，Token 值脱敏显示（如 `sk-****abc123`）
  - HTTP 状态码: 200 OK
- [ ] `DELETE /api/tokens/:id` - 删除 Token
  - HTTP 状态码: 204 No Content

### AC4: Token 脱敏显示
- [ ] 创建 Token 后，完整显示一次（响应中包含完整 Token）
- [ ] 后续查询（GET /api/tokens）自动脱敏，格式: `sk-****{最后4位}`
- [ ] API 响应中的 Token 对象包含 `token_display` 字段（脱敏后的值）

### AC5: 参数验证
- [ ] 名称不能为空
- [ ] 名称长度不超过 100 字符
- [ ] 过期时间必须是未来时间（如果提供）
- [ ] 验证失败返回 400 Bad Request 并提供错误消息

### AC6: 单元测试
- [ ] Token 生成函数测试覆盖率 > 80%
- [ ] Token 唯一性测试（生成 1000 个 Token，无重复）
- [ ] Token 格式测试（符合正则表达式）
- [ ] CRUD API 测试（创建、查询、删除）
- [ ] 脱敏功能测试
- [ ] 参数验证测试

## 技术设计

### 数据模型

```go
// internal/models/token.go
package models

import "time"

// Token API 令牌模型
type Token struct {
    ID        uint       `gorm:"primaryKey" json:"id"`
    Name      string     `gorm:"type:varchar(100);not null" json:"name"`
    Token     string     `gorm:"type:varchar(100);uniqueIndex;not null" json:"token"`
    Enabled   bool       `gorm:"not null;default:true" json:"enabled"`
    ExpiresAt *time.Time `json:"expires_at"`
    CreatedAt time.Time  `json:"created_at"`
    UpdatedAt time.Time  `json:"updated_at"`
}

// TableName 指定表名
func (Token) TableName() string {
    return "tokens"
}
```

### Token 生成逻辑

```go
// internal/token/service.go
package token

import (
    "crypto/rand"
    "encoding/base64"
    "errors"
    "fmt"
)

// GenerateToken 生成唯一的 API Token
// 格式: sk- + 32 字节 base64 编码
func GenerateToken() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    token := "sk-" + base64.URLEncoding.EncodeToString(bytes)
    return token, nil
}
```

### Token 脱敏逻辑

```go
// MaskToken 脱敏显示 Token
// 格式: sk-****{最后4位}
func MaskToken(token string) string {
    if len(token) < 8 {
        return "****"
    }
    last4 := token[len(token)-4:]
    return "sk-****" + last4
}
```

### API 端点

#### POST /api/tokens
**请求**:
```json
{
  "name": "我的开发 Token",
  "expires_at": "2025-12-31T23:59:59Z"
}
```

**响应 (201 Created)**:
```json
{
  "id": 1,
  "name": "我的开发 Token",
  "token": "sk-xyzabc1234567890abcdef1234567890xyz123",
  "token_display": "sk-****y123",
  "enabled": true,
  "expires_at": "2025-12-31T23:59:59Z",
  "created_at": "2025-10-02T10:00:00Z",
  "updated_at": "2025-10-02T10:00:00Z"
}
```

#### GET /api/tokens
**响应 (200 OK)**:
```json
[
  {
    "id": 1,
    "name": "我的开发 Token",
    "token_display": "sk-****y123",
    "enabled": true,
    "expires_at": "2025-12-31T23:59:59Z",
    "created_at": "2025-10-02T10:00:00Z",
    "updated_at": "2025-10-02T10:00:00Z"
  }
]
```

#### DELETE /api/tokens/:id
**响应 (204 No Content)**

### 三层架构

1. **Repository 层** (`internal/token/repository.go`)
   - `CreateToken(token *models.Token) error`
   - `FindAllTokens() ([]*models.Token, error)`
   - `FindTokenByID(id uint) (*models.Token, error)`
   - `FindTokenByValue(tokenValue string) (*models.Token, error)`
   - `DeleteToken(id uint) error`

2. **Service 层** (`internal/token/service.go`)
   - `GenerateToken() (string, error)` - 生成唯一 Token
   - `CreateToken(name string, expiresAt *time.Time) (*models.Token, error)`
   - `ListTokens() ([]*TokenDTO, error)` - 返回脱敏后的 Token 列表
   - `DeleteToken(id uint) error`
   - `ValidateToken(tokenValue string) (*models.Token, error)` - 验证 Token（Story 6.2 使用）

3. **Handler 层** (`internal/api/handlers/token_handler.go`)
   - `CreateToken(c *gin.Context)` - POST /api/tokens
   - `ListTokens(c *gin.Context)` - GET /api/tokens
   - `DeleteToken(c *gin.Context)` - DELETE /api/tokens/:id

### DTO 定义

```go
// internal/token/dto.go
package token

import "time"

// CreateTokenRequest 创建 Token 请求
type CreateTokenRequest struct {
    Name      string     `json:"name" binding:"required,max=100"`
    ExpiresAt *time.Time `json:"expires_at"`
}

// TokenDTO Token 数据传输对象
type TokenDTO struct {
    ID           uint       `json:"id"`
    Name         string     `json:"name"`
    Token        string     `json:"token,omitempty"` // 仅在创建时返回
    TokenDisplay string     `json:"token_display"`   // 脱敏显示
    Enabled      bool       `json:"enabled"`
    ExpiresAt    *time.Time `json:"expires_at"`
    CreatedAt    time.Time  `json:"created_at"`
    UpdatedAt    time.Time  `json:"updated_at"`
}
```

## 测试策略

### 单元测试用例

#### Token 生成测试
1. **测试 Token 格式**: 生成的 Token 符合正则 `^sk-[a-zA-Z0-9+/]{43}$`
2. **测试唯一性**: 生成 1000 个 Token，验证无重复
3. **测试错误处理**: 模拟随机数生成失败

#### Repository 层测试
1. **创建 Token**: 成功创建并返回 ID
2. **查询 Token 列表**: 返回所有 Token
3. **按 ID 查询**: 成功返回指定 Token
4. **按值查询**: 成功返回指定 Token
5. **删除 Token**: 成功删除并返回无错误
6. **唯一性约束**: 插入重复 Token 值返回错误

#### Service 层测试
1. **创建 Token**: 成功生成唯一 Token 并保存
2. **列出 Token**: 返回脱敏后的 Token 列表
3. **删除 Token**: 成功删除 Token
4. **过期时间验证**: 过期时间必须是未来时间
5. **Token 验证**: 验证有效 Token 返回对象，无效返回错误

#### Handler 层测试
1. **POST /api/tokens**: 返回 201 和完整 Token
2. **POST /api/tokens (参数错误)**: 返回 400 和错误消息
3. **GET /api/tokens**: 返回 200 和脱敏 Token 列表
4. **DELETE /api/tokens/:id**: 返回 204
5. **DELETE /api/tokens/:id (不存在)**: 返回 404

## 依赖项

- GORM (数据库 ORM)
- Gin (HTTP 框架)
- crypto/rand (安全随机数)
- encoding/base64 (Base64 编码)

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Token 唯一性冲突 | 中 | 使用数据库唯一索引，插入失败时重新生成 |
| 随机数生成失败 | 低 | 捕获错误并返回友好消息 |
| Token 泄露 | 高 | 脱敏显示，仅创建时显示一次 |

## 后续 Story

- **Story 6.2**: Token 验证中间件 (实现认证逻辑)

---

**创建时间**: 2025-10-02
**负责人**: 浮浮酱 (幽浮喵)
**状态**: In Progress
