# Story 6.2: Token 验证中间件

**Epic**: Epic 6 - 令牌管理 (FR15-FR16)
**优先级**: P0 (MUST HAVE)
**估算时间**: 1 天
**状态**: ✅ Completed
**依赖**: Story 6.1 (Token 生成和存储)
**完成时间**: 2025-10-02

---

## 用户故事

作为一个 **API 用户**，我希望**使用 Token 进行身份验证**，以便安全地访问 `/v1/messages` 和 `/v1/chat/completions` 等受保护的端点。

## 需求背景 (FR16)

- **认证方式**: 通过 HTTP 请求头 `Authorization: Bearer <token>` 传递 Token
- **验证逻辑**:
  1. 从请求头提取 Token
  2. 查询数据库验证 Token 有效性
  3. 检查 Token 是否启用 (`enabled = true`)
  4. 检查 Token 是否过期 (`expires_at > NOW()`)
- **失败响应**: `401 Unauthorized`
- **应用端点**: `/v1/messages` 和 `/v1/chat/completions`

## 验收标准

### AC1: Token 验证中间件实现
- [ ] 创建 `TokenAuthMiddleware()` 函数
- [ ] 从 `Authorization: Bearer <token>` 头提取 Token
- [ ] 调用 `Service.ValidateToken()` 验证 Token
- [ ] 验证成功时，将 Token 信息存入 Gin Context
- [ ] 验证失败时，返回 `401 Unauthorized` 并提供错误信息

### AC2: 错误处理
- [ ] 缺少 Authorization 头 → 401 "Missing authorization header"
- [ ] Authorization 格式错误 → 401 "Invalid authorization format"
- [ ] Token 无效 → 401 "Invalid token"
- [ ] Token 已禁用 → 401 "Token disabled"
- [ ] Token 已过期 → 401 "Token expired"

### AC3: 中间件集成
- [ ] 将中间件应用到 `/v1/messages` 端点
- [ ] 将中间件应用到 `/v1/chat/completions` 端点
- [ ] 中间件不影响不需要认证的端点（如健康检查）

### AC4: Context 数据存储
- [ ] 验证成功后，将 Token ID 存入 Context (`token_id`)
- [ ] 将 Token 对象存入 Context (`token`)
- [ ] 后续 Handler 可以从 Context 获取 Token 信息

### AC5: 单元测试
- [ ] 测试成功验证场景
- [ ] 测试缺少 Authorization 头
- [ ] 测试 Authorization 格式错误 (不是 Bearer 格式)
- [ ] 测试无效 Token
- [ ] 测试已禁用 Token
- [ ] 测试已过期 Token
- [ ] 测试 Context 数据存储

### AC6: 集成测试
- [ ] 使用有效 Token 访问 `/v1/messages` 成功
- [ ] 使用无效 Token 访问 `/v1/messages` 返回 401
- [ ] 不带 Token 访问 `/v1/messages` 返回 401
- [ ] 访问不需要认证的端点（如 `/health`）成功

## 技术设计

### 中间件实现

```go
// internal/api/middleware/auth.go
package middleware

import (
    "errors"
    "net/http"
    "strings"

    "github.com/Mieluoxxx/Siriusx-API/internal/token"
    "github.com/gin-gonic/gin"
)

// TokenAuthMiddleware Token 验证中间件
func TokenAuthMiddleware(tokenService *token.Service) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 提取 Authorization 头
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": gin.H{
                    "code":    "MISSING_AUTH_HEADER",
                    "message": "Missing authorization header",
                },
            })
            c.Abort()
            return
        }

        // 2. 解析 Bearer Token
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": gin.H{
                    "code":    "INVALID_AUTH_FORMAT",
                    "message": "Invalid authorization format. Expected: Bearer <token>",
                },
            })
            c.Abort()
            return
        }

        tokenValue := parts[1]

        // 3. 验证 Token
        tok, err := tokenService.ValidateToken(tokenValue)
        if err != nil {
            handleAuthError(c, err)
            c.Abort()
            return
        }

        // 4. 将 Token 信息存入 Context
        c.Set("token_id", tok.ID)
        c.Set("token", tok)

        c.Next()
    }
}

// handleAuthError 处理认证错误
func handleAuthError(c *gin.Context, err error) {
    var code, message string

    switch {
    case errors.Is(err, token.ErrInvalidToken):
        code = "INVALID_TOKEN"
        message = "Invalid token"
    case errors.Is(err, token.ErrTokenDisabled):
        code = "TOKEN_DISABLED"
        message = "Token disabled"
    case errors.Is(err, token.ErrTokenExpired):
        code = "TOKEN_EXPIRED"
        message = "Token expired"
    default:
        code = "AUTH_ERROR"
        message = "Authentication failed"
    }

    c.JSON(http.StatusUnauthorized, gin.H{
        "error": gin.H{
            "code":    code,
            "message": message,
        },
    })
}
```

### 路由集成

```go
// internal/api/router.go

// 在 SetupRouter 函数中添加 Token 认证中间件
func SetupRouter(db *gorm.DB, encryptionKey []byte) *gin.Engine {
    router := gin.Default()

    // ... 健康检查等不需要认证的路由 ...

    // 创建 Token Service
    tokenRepo := token.NewRepository(db)
    tokenService := token.NewService(tokenRepo)

    // AI API 路由组 (需要认证)
    v1 := router.Group("/v1")
    v1.Use(middleware.TokenAuthMiddleware(tokenService))
    {
        v1.POST("/messages", handlers.HandleMessages)
        v1.POST("/chat/completions", handlers.HandleChatCompletions)
    }

    // 管理 API 路由组 (不需要认证，或使用其他认证方式)
    apiGroup := router.Group("/api")
    {
        // ... 现有的管理 API ...
    }

    return router
}
```

### Context 数据获取

```go
// 在 Handler 中获取 Token 信息
func HandleMessages(c *gin.Context) {
    // 获取 Token ID
    tokenID, exists := c.Get("token_id")
    if !exists {
        // 不应该发生，因为中间件已验证
        c.JSON(500, gin.H{"error": "Internal error"})
        return
    }

    // 获取完整 Token 对象
    tok, _ := c.Get("token")
    token := tok.(*models.Token)

    // ... 使用 Token 信息 ...
}
```

## 测试策略

### 单元测试用例

#### 中间件测试 (`middleware/auth_test.go`)

1. **成功验证**:
   - 请求头: `Authorization: Bearer sk-validtoken123`
   - 预期: 中间件通过，Context 包含 Token 信息

2. **缺少 Authorization 头**:
   - 请求头: (无)
   - 预期: 401 MISSING_AUTH_HEADER

3. **Authorization 格式错误**:
   - 请求头: `Authorization: sk-token123` (缺少 Bearer)
   - 预期: 401 INVALID_AUTH_FORMAT

4. **无效 Token**:
   - 请求头: `Authorization: Bearer sk-invalid`
   - 预期: 401 INVALID_TOKEN

5. **已禁用 Token**:
   - 请求头: `Authorization: Bearer sk-disabled123`
   - 预期: 401 TOKEN_DISABLED

6. **已过期 Token**:
   - 请求头: `Authorization: Bearer sk-expired123`
   - 预期: 401 TOKEN_EXPIRED

### 集成测试用例

1. **完整请求流程测试**:
   - 创建 Token → 使用 Token 访问 `/v1/messages` → 验证成功
   - 禁用 Token → 使用 Token 访问 `/v1/messages` → 验证失败

2. **端点覆盖测试**:
   - `/v1/messages` 需要认证
   - `/v1/chat/completions` 需要认证
   - `/health` 不需要认证
   - `/api/tokens` 不需要认证（管理 API）

3. **Epic 6 集成测试** (`test/integration/epic6_integration_test.go`):
   - `TestEpic6_TokenLifecycle`: 完整 Token 生命周期（创建→使用→列表→删除→验证失效）
   - `TestEpic6_TokenDisableEnable`: Token 禁用/启用功能
   - `TestEpic6_TokenExpiration`: Token 过期验证
   - `TestEpic6_MultipleTokens`: 多 Token 管理
   - `TestEpic6_InvalidTokenScenarios`: 各种无效 Token 场景（缺少头、格式错误、无效 Token 等）

## 依赖项

- Gin (HTTP 框架)
- Story 6.1 (Token Service 的 ValidateToken 方法)

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 中间件性能影响 | 中 | 每次请求都要查询数据库，可能影响性能 | 后续可添加 Token 缓存（Redis） |
| Token 泄露 | 高 | Token 被窃取后可无限使用 | 实现 Token 刷新机制、IP 白名单 |
| 并发验证问题 | 低 | 数据库连接池配置正确 | GORM 已配置连接池 |

## 后续优化

- **Token 缓存**: 使用 Redis 缓存有效 Token，减少数据库查询
- **速率限制**: 防止 Token 暴力破解
- **Token 刷新**: 实现 Token 续期机制
- **审计日志**: 记录所有认证尝试

---

**创建时间**: 2025-10-02
**完成时间**: 2025-10-02
**负责人**: 浮浮酱 (幽浮喵)
**状态**: ✅ Completed

## 测试结果

### 单元测试 (internal/api/middleware/auth_test.go)
- ✅ 7/7 测试通过
- 覆盖场景：成功验证、缺少头、格式错误、无效 Token、已禁用 Token、已过期 Token、Context 数据存储

### 集成测试 (test/integration/epic6_integration_test.go)
- ✅ 5/5 测试通过（包含 9 个子场景）
- 测试内容：
  - Token 完整生命周期
  - Token 禁用/启用
  - Token 过期验证
  - 多 Token 管理
  - 各种无效场景

**总计**: 12 个测试用例全部通过 ✅
