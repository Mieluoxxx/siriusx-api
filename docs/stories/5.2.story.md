# Story 5.2: 故障检测逻辑

> **Epic 5: 负载均衡系统**
> **Story**: 5.2
> **估算**: 1.5 天
> **负责人**: AI Assistant
> **状态**: Done

## 📋 需求概述

实现智能故障检测系统，能够自动识别供应商故障、统计故障次数、实现冷却机制和自动恢复，确保系统的高可用性和稳定性。

## 🎯 核心功能

### 1. 故障检测函数
- **IsFailure 函数**: `IsFailure(err error, resp *http.Response) bool`
- **请求超时检测**: 30秒超时自动标记为故障
- **HTTP状态码检测**: 5xx服务器错误视为故障
- **限流检测**: HTTP 429 Too Many Requests视为故障
- **连接失败检测**: 网络连接失败视为故障

### 2. 故障计数器机制
- **连续故障统计**: 记录每个供应商的连续故障次数
- **故障阈值**: 连续3次故障触发冷却机制
- **故障窗口**: 基于时间窗口的故障率统计
- **故障类型分类**: 区分不同类型的故障进行统计

### 3. 冷却期和恢复机制
- **冷却期设置**: 故障供应商冷却5分钟
- **自动恢复**: 冷却期结束后自动尝试恢复
- **渐进式恢复**: 恢复后逐步增加流量权重
- **熔断保护**: 防止故障供应商影响整体服务

## 🏗️ 技术设计

### 架构概览
```
┌─────────────────────────────────────────┐
│          FailureDetector Interface      │
├─────────────────────────────────────────┤
│  + IsFailure(err, resp) bool            │
│  + RecordFailure(providerID)            │
│  + RecordSuccess(providerID)            │
│  + IsAvailable(providerID) bool         │
│  + GetFailureStats(providerID) Stats    │
└─────────────────────────────────────────┘
                     ▲
                     │
┌─────────────────────────────────────────┐
│        DefaultFailureDetector           │
├─────────────────────────────────────────┤
│  - failureState map[uint]*ProviderState │
│  - config *FailureDetectorConfig        │
│  - mutex sync.RWMutex                   │
├─────────────────────────────────────────┤
│  + IsFailure(err, resp) bool            │
│  + RecordFailure(providerID)            │
│  + RecordSuccess(providerID)            │
│  + IsAvailable(providerID) bool         │
│  + cleanup() (background goroutine)     │
└─────────────────────────────────────────┘
```

### 故障检测算法
```go
// 故障检测核心逻辑
func (d *DefaultFailureDetector) IsFailure(err error, resp *http.Response) bool {
    // 1. 检查错误类型
    if err != nil {
        if isTimeoutError(err) || isConnectionError(err) {
            return true
        }
    }

    // 2. 检查HTTP响应状态
    if resp != nil {
        switch {
        case resp.StatusCode >= 500 && resp.StatusCode < 600: // 5xx错误
            return true
        case resp.StatusCode == 429: // 限流
            return true
        }
    }

    return false
}
```

### 数据结构设计
```go
// FailureDetector 故障检测器接口
type FailureDetector interface {
    IsFailure(err error, resp *http.Response) bool
    RecordFailure(providerID uint)
    RecordSuccess(providerID uint)
    IsAvailable(providerID uint) bool
    GetFailureStats(providerID uint) *FailureStats
    Reset(providerID uint)
}

// ProviderState 供应商状态
type ProviderState struct {
    ProviderID        uint                  // 供应商ID
    ConsecutiveFailures int                 // 连续故障次数
    TotalFailures      int64               // 总故障次数
    TotalRequests      int64               // 总请求次数
    LastFailureTime    time.Time           // 最后故障时间
    LastSuccessTime    time.Time           // 最后成功时间
    CooldownUntil      time.Time           // 冷却结束时间
    IsInCooldown       bool                // 是否在冷却期
    FailureTypes       map[FailureType]int // 故障类型统计
    mutex              sync.RWMutex        // 状态保护锁
}

// FailureType 故障类型枚举
type FailureType string

const (
    TimeoutFailure    FailureType = "timeout"
    ConnectionFailure FailureType = "connection"
    ServerError       FailureType = "server_error"
    RateLimitFailure  FailureType = "rate_limit"
)

// FailureDetectorConfig 故障检测配置
type FailureDetectorConfig struct {
    FailureThreshold   int           // 故障阈值 (默认3次)
    CooldownDuration   time.Duration // 冷却时长 (默认5分钟)
    TimeoutThreshold   time.Duration // 超时阈值 (默认30秒)
    CleanupInterval    time.Duration // 清理间隔 (默认1小时)
    MaxFailureHistory  int           // 最大故障历史记录数
}
```

## 🔧 实现计划

### Phase 1: 基础故障检测 (2h)
- [ ] 定义 FailureDetector 接口
- [ ] 实现 IsFailure 核心检测逻辑
- [ ] 支持超时、5xx、429、连接失败检测
- [ ] 错误类型分类和识别

### Phase 2: 故障状态管理 (3h)
- [ ] 实现 ProviderState 状态管理
- [ ] 故障计数器和连续故障追踪
- [ ] 故障类型统计和分析
- [ ] 并发安全的状态更新

### Phase 3: 冷却和恢复机制 (2h)
- [ ] 冷却期触发和管理
- [ ] 自动恢复检测
- [ ] 渐进式流量恢复
- [ ] 背景清理任务

### Phase 4: 测试和验证 (2h)
- [ ] 单元测试 (各种故障场景)
- [ ] 集成测试 (模拟真实故障)
- [ ] 性能测试 (高并发故障检测)
- [ ] 准确率验证测试

## 📊 验收标准

### 功能验收
- [x] ✅ 实现 `IsFailure` 故障检测函数
- [ ] ✅ 支持超时、5xx、429、连接失败检测
- [ ] ✅ 故障计数器机制 (连续3次 → 冷却5分钟)
- [ ] ✅ 自动恢复机制 (冷却期后恢复)

### 质量验收
- [ ] 🎯 故障检测准确率 > 95%
- [ ] ⏱️ 冷却期机制正常工作
- [ ] 🧪 单元测试: 模拟各种故障场景
- [ ] 🔗 集成测试: 真实供应商故障模拟

### 性能验收
- [ ] ⚡ 故障检测延迟 < 1ms
- [ ] 🔄 支持高并发故障检测
- [ ] 💾 内存使用合理 (有限状态存储)
- [ ] 🧹 自动清理过期状态

## 🧪 测试策略

### 1. 故障检测单元测试
```go
func TestFailureDetector_IsFailure(t *testing.T) {
    // 测试超时错误检测
    // 测试连接错误检测
    // 测试5xx状态码检测
    // 测试429限流检测
    // 测试正常响应
}

func TestFailureDetector_FailureCounter(t *testing.T) {
    // 测试连续故障计数
    // 测试冷却期触发
    // 测试成功后计数重置
}
```

### 2. 故障场景模拟测试
- **超时场景**: 模拟30秒超时
- **服务器错误**: 模拟500、502、503等错误
- **限流场景**: 模拟429 Too Many Requests
- **连接失败**: 模拟网络连接断开
- **间歇性故障**: 模拟偶发性错误

### 3. 冷却和恢复测试
- **冷却期验证**: 验证5分钟冷却期正确执行
- **自动恢复**: 验证冷却期后自动恢复
- **渐进式恢复**: 验证流量逐步恢复
- **并发安全**: 验证多线程环境下的状态一致性

## 🔗 依赖关系

### 输入依赖
- `net/http` - HTTP响应和错误处理
- `time` - 时间管理和超时检测
- `context` - 请求上下文和取消处理

### 输出依赖
- 为智能故障转移 (Story 5.3) 提供故障检测能力
- 为负载均衡器提供供应商可用性判断
- 为监控系统提供故障统计数据

### 技术依赖
- Go 1.21+
- `sync` - 并发安全
- `errors` - 错误处理和分类

## 📈 监控指标

### 业务指标
- **故障检测准确率**: 正确识别故障的百分比
- **误报率**: 错误标记健康服务为故障的比例
- **恢复时间**: 从故障到恢复的平均时间
- **供应商可用率**: 各供应商的可用性百分比

### 技术指标
- **检测延迟**: 故障检测的响应时间
- **状态更新性能**: 并发状态更新的吞吐量
- **内存使用**: 故障状态存储的内存占用
- **清理效率**: 过期状态清理的效率

## 🚀 部署考虑

### 配置参数
- **故障阈值**: 可配置的连续故障次数阈值
- **冷却时长**: 可配置的冷却期时间
- **超时阈值**: 可配置的请求超时时间
- **清理策略**: 状态清理的时间和策略

### 运维支持
- **故障统计接口**: 提供故障统计查询API
- **状态重置功能**: 支持手动重置供应商状态
- **实时监控**: 供应商状态实时监控
- **告警集成**: 故障事件告警通知

## 🎯 质量保证

### 代码质量
- **单一职责**: 每个组件专注单一功能
- **接口抽象**: 清晰的接口定义和实现分离
- **错误处理**: 完善的错误分类和处理
- **文档注释**: 详细的函数和接口文档

### 可靠性保证
- **并发安全**: 使用适当的锁机制保护共享状态
- **优雅降级**: 故障检测本身不能成为单点故障
- **资源管理**: 避免内存泄漏和资源浪费
- **边界处理**: 处理各种异常和边界情况

---

**实现优先级**: P0 (核心功能)
**风险评估**: 中等风险，需要准确的故障识别逻辑
**后续优化**: 支持更多故障类型，机器学习辅助故障预测